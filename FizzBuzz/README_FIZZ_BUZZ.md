# üéÆ FizzBuzz - Proyecto de Pr√°ctica

## üìã ¬øQu√© es FizzBuzz?

FizzBuzz es un **ejercicio cl√°sico de programaci√≥n** utilizado frecuentemente en entrevistas t√©cnicas. Aunque parece simple, tiene varias trampas l√≥gicas que lo hacen perfecto para practicar:
- Operadores matem√°ticos
- Estructuras condicionales
- Razonamiento l√≥gico
- Orden de evaluaci√≥n

Es parte del curso **"100 Days of Code: The Complete Python Pro Bootcamp"** de Udemy.

---

## üéØ Objetivo del Ejercicio

Crear un programa que imprima los n√∫meros del **1 al 100**, pero con estas reglas especiales:

| Condici√≥n | Output |
|-----------|--------|
| N√∫mero divisible por 3 | `"Fizz"` |
| N√∫mero divisible por 5 | `"Buzz"` |
| N√∫mero divisible por 3 Y 5 | `"FizzBuzz"` |
| Ninguna de las anteriores | El n√∫mero |

### Ejemplo de salida esperada:
```
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
...
```

---

## ‚úÖ Soluci√≥n Correcta

```python
for number in range(1, 101):
    if number % 3 == 0 and number % 5 == 0:
        print("FizzBuzz")
    elif number % 3 == 0:
        print("Fizz")
    elif number % 5 == 0:
        print("Buzz")
    else:
        print(number)
```

---

## üîç Explicaci√≥n Detallada

### **1. El Loop For**
```python
for number in range(1, 101):
```

- `range(1, 101)` genera n√∫meros del 1 al 100 (el 101 NO se incluye)
- En cada iteraci√≥n, `number` toma el valor del n√∫mero actual
- El loop se ejecuta 100 veces

---

### **2. El Operador M√≥dulo (%)**

El operador `%` (m√≥dulo) devuelve el **residuo** de una divisi√≥n.

**Ejemplos:**
```python
15 % 3 = 0   # 15 √∑ 3 = 5, residuo = 0
15 % 5 = 0   # 15 √∑ 5 = 3, residuo = 0
16 % 3 = 1   # 16 √∑ 3 = 5, residuo = 1
17 % 5 = 2   # 17 √∑ 5 = 3, residuo = 2
```

**Regla de oro:**
- Si `number % divisor == 0` ‚Üí El n√∫mero ES divisible
- Si `number % divisor != 0` ‚Üí El n√∫mero NO es divisible

---

### **3. Orden de las Condiciones (CR√çTICO)**

```python
if number % 3 == 0 and number % 5 == 0:  # ‚Üê M√ÅS ESPEC√çFICO primero
    print("FizzBuzz")
elif number % 3 == 0:                     # ‚Üê Menos espec√≠fico
    print("Fizz")
elif number % 5 == 0:                     # ‚Üê Menos espec√≠fico
    print("Buzz")
else:                                      # ‚Üê Si ninguna es verdadera
    print(number)
```

**¬øPor qu√© este orden?**

Imagina el n√∫mero **15**:
- Es divisible por 3 ‚úÖ
- Es divisible por 5 ‚úÖ
- Por lo tanto, debe imprimir "FizzBuzz"

Si pusieras la condici√≥n de "divisible por 3" primero:
```python
if number % 3 == 0:        # 15 % 3 == 0? ‚úÖ S√ç
    print("Fizz")           # ‚Üê Imprime "Fizz" y TERMINA
elif number % 5 == 0:       # ‚Üê NUNCA llega aqu√≠
    ...
```

**El problema:** Una vez que un `if` o `elif` es verdadero, Python ejecuta ese bloque y **salta el resto de condiciones**.

Por eso la regla es:
> **Siempre verifica la condici√≥n M√ÅS ESPEC√çFICA primero**

---

### **4. El Operador `and`**

```python
if number % 3 == 0 and number % 5 == 0:
```

El operador `and` requiere que **AMBAS** condiciones sean verdaderas.

| number % 3 == 0 | number % 5 == 0 | Resultado |
|----------------|----------------|-----------|
| True | True | **True** ‚úÖ |
| True | False | **False** ‚ùå |
| False | True | **False** ‚ùå |
| False | False | **False** ‚ùå |

---

## üìä Ejemplos Paso a Paso

### **Ejemplo 1: N√∫mero 3**
```python
number = 3
```

1. `if 3 % 3 == 0 and 3 % 5 == 0:`
   - `3 % 3 = 0` ‚úÖ (True)
   - `3 % 5 = 3` ‚ùå (False)
   - `True and False = False` ‚ùå
   - NO se ejecuta este bloque

2. `elif 3 % 3 == 0:`
   - `3 % 3 = 0` ‚úÖ (True)
   - Se ejecuta: `print("Fizz")`

**Salida:** `Fizz`

---

### **Ejemplo 2: N√∫mero 5**
```python
number = 5
```

1. `if 5 % 3 == 0 and 5 % 5 == 0:`
   - `5 % 3 = 2` ‚ùå (False)
   - `5 % 5 = 0` ‚úÖ (True)
   - `False and True = False` ‚ùå
   - NO se ejecuta

2. `elif 5 % 3 == 0:`
   - `5 % 3 = 2` ‚ùå (False)
   - NO se ejecuta

3. `elif 5 % 5 == 0:`
   - `5 % 5 = 0` ‚úÖ (True)
   - Se ejecuta: `print("Buzz")`

**Salida:** `Buzz`

---

### **Ejemplo 3: N√∫mero 15**
```python
number = 15
```

1. `if 15 % 3 == 0 and 15 % 5 == 0:`
   - `15 % 3 = 0` ‚úÖ (True)
   - `15 % 5 = 0` ‚úÖ (True)
   - `True and True = True` ‚úÖ
   - Se ejecuta: `print("FizzBuzz")`
   - **TERMINA** (no verifica los dem√°s elif)

**Salida:** `FizzBuzz`

---

### **Ejemplo 4: N√∫mero 7**
```python
number = 7
```

1. `if 7 % 3 == 0 and 7 % 5 == 0:`
   - `7 % 3 = 1` ‚ùå (False)
   - `7 % 5 = 2` ‚ùå (False)
   - NO se ejecuta

2. `elif 7 % 3 == 0:`
   - `7 % 3 = 1` ‚ùå (False)
   - NO se ejecuta

3. `elif 7 % 5 == 0:`
   - `7 % 5 = 2` ‚ùå (False)
   - NO se ejecuta

4. `else:`
   - Se ejecuta: `print(7)`

**Salida:** `7`

---

## ‚ùå Errores Comunes y Mis Errores

### **Error 1: Olvidar `== 0` en las condiciones**

**‚ùå C√≥digo Incorrecto:**
```python
if number % 3:
    print("Fizz")
```

**¬øPor qu√© est√° mal?**
- `number % 3` devuelve el residuo (0, 1, o 2)
- En Python, `0` es `False` y cualquier otro n√∫mero es `True`
- Por lo tanto:
  - `if 3 % 3:` ‚Üí `if 0:` ‚Üí `False` ‚ùå
  - `if 4 % 3:` ‚Üí `if 1:` ‚Üí `True` ‚úÖ

**Resultado:** ¬°Hace exactamente lo contrario de lo que quer√≠as!

**‚úÖ C√≥digo Correcto:**
```python
if number % 3 == 0:
    print("Fizz")
```

---

### **Error 2: Orden incorrecto de condiciones**

**‚ùå C√≥digo Incorrecto:**
```python
for number in range(1, 101):
    if number % 3 == 0:           # ‚Üê Verifica esto PRIMERO
        print("Fizz")
    elif number % 5 == 0:
        print("Buzz")
    elif number % 3 == 0 and number % 5 == 0:  # ‚Üê NUNCA llega aqu√≠
        print("FizzBuzz")
    else:
        print(number)
```

**¬øQu√© pasa con el n√∫mero 15?**
1. `15 % 3 == 0` ‚Üí ‚úÖ True
2. Imprime "Fizz"
3. TERMINA (nunca llega a la condici√≥n de FizzBuzz)

**Resultado:** Los n√∫meros como 15, 30, 45, 60, 75, 90 imprimen "Fizz" en lugar de "FizzBuzz"

**‚úÖ C√≥digo Correcto:**
```python
for number in range(1, 101):
    if number % 3 == 0 and number % 5 == 0:  # ‚Üê M√ÅS ESPEC√çFICO primero
        print("FizzBuzz")
    elif number % 3 == 0:
        print("Fizz")
    elif number % 5 == 0:
        print("Buzz")
    else:
        print(number)
```

---

## üß† Tipos de Errores

### **1. Errores de Sintaxis**
Python te los marca inmediatamente.
```python
if number % 3 == 0  # ‚ùå Falta :
    print("Fizz")
```

### **2. Errores L√≥gicos**
El c√≥digo corre, pero hace algo incorrecto.
```python
if number % 3 == 0:      # Orden incorrecto
    print("Fizz")
elif number % 3 == 0 and number % 5 == 0:
    print("FizzBuzz")
```

### **3. Errores Conceptuales**
No entiendes el concepto subyacente.
```python
if number % 3:  # No entiendes qu√© significa el m√≥dulo
    print("Fizz")
```

**En este ejercicio, mis errores fueron principalmente del tipo 2 y 3** (l√≥gicos y conceptuales), NO de sintaxis de Python.

---

## üé® Soluciones Alternativas

### **Versi√≥n 1: Construcci√≥n de String (M√°s elegante)**

```python
for number in range(1, 101):
    output = ""
    
    if number % 3 == 0:
        output += "Fizz"
    
    if number % 5 == 0:
        output += "Buzz"
    
    if output == "":
        output = number
    
    print(output)
```

**Ventajas:**
- No necesitas verificar `and` para FizzBuzz
- Construye el string paso a paso
- M√°s flexible si quieres agregar m√°s reglas

**C√≥mo funciona:**
- Si es divisible por 3: a√±ade "Fizz"
- Si es divisible por 5: a√±ade "Buzz"
- Si es divisible por ambos: el string ser√° "FizzBuzz"
- Si no se a√±adi√≥ nada: usa el n√∫mero

---

### **Versi√≥n 2: Operador Ternario (Compacta)**

```python
for number in range(1, 101):
    print(
        "FizzBuzz" if number % 15 == 0 else
        "Fizz" if number % 3 == 0 else
        "Buzz" if number % 5 == 0 else
        number
    )
```

**Nota:** `number % 15 == 0` es equivalente a `number % 3 == 0 and number % 5 == 0`

---

### **Versi√≥n 3: Con Diccionario (Avanzada)**

```python
for number in range(1, 101):
    output = ""
    rules = {3: "Fizz", 5: "Buzz"}
    
    for divisor, word in rules.items():
        if number % divisor == 0:
            output += word
    
    print(output if output else number)
```

**Ventaja:** F√°cil agregar m√°s reglas sin modificar la l√≥gica.

---

## üìä Tabla de Resultados Esperados

| N√∫meros | Output |
|---------|--------|
| 1, 2, 4, 7, 8, 11, 13, 14... | El n√∫mero mismo |
| 3, 6, 9, 12, 18, 21, 24... | Fizz |
| 5, 10, 20, 25, 35, 40, 50... | Buzz |
| 15, 30, 45, 60, 75, 90 | FizzBuzz |

**Verificaci√≥n r√°pida:**
- De 1 a 100 hay **6 n√∫meros** que son divisibles por 3 y 5: `15, 30, 45, 60, 75, 90`
- Todos deben imprimir "FizzBuzz"

---

## üí° Conceptos Clave Aprendidos

### **1. Operador M√≥dulo (%)**
- Devuelve el residuo de una divisi√≥n
- Si el residuo es 0, el n√∫mero es divisible
- Usado frecuentemente para verificar divisibilidad

### **2. Orden de Condiciones**
- En `if/elif/else`, solo se ejecuta el PRIMER bloque verdadero
- Siempre verifica las condiciones M√ÅS ESPEC√çFICAS primero
- El orden importa en la l√≥gica condicional

### **3. Operadores L√≥gicos**
- `and` requiere que AMBAS condiciones sean verdaderas
- `or` requiere que AL MENOS UNA sea verdadera
- `not` invierte el valor de verdad

### **4. Truthiness en Python**
- `0` es `False`
- Cualquier n√∫mero diferente de 0 es `True`
- Por eso `if number % 3:` funciona pero hace lo contrario

---

## üéØ Lecciones Aprendidas

### **Lo que hice bien:**
‚úÖ Sintaxis correcta de Python  
‚úÖ Uso correcto del `for` loop  
‚úÖ Estructura general del c√≥digo  
‚úÖ Indentaci√≥n correcta  

### **Lo que necesito mejorar:**
‚ùå Entender mejor el operador m√≥dulo  
‚ùå Pensar en el orden l√≥gico de las condiciones  
‚ùå Verificar los casos especiales (como 15, 30, 45)  
‚ùå Leer las especificaciones con cuidado (espacio en "FizzBuzz")  

### **Lo m√°s importante:**
> **Mis errores fueron L√ìGICOS y CONCEPTUALES, no de programaci√≥n en Python.**

Esto significa que:
- Mi Python est√° bien
- Necesito trabajar m√°s en razonamiento l√≥gico
- Necesito practicar m√°s con matem√°ticas b√°sicas aplicadas
- Debo pensar en casos especiales antes de escribir c√≥digo

---

**¬øC√≥mo puedo mejorar?**
- Practicar m√°s ejercicios de l√≥gica
- Pensar en "casos edge" antes de programar
- Hacer una tabla de verdad mental antes de escribir condiciones
- Probar el c√≥digo con varios valores manualmente

---

**¬°Este ejercicio me ense√±√≥ que la programaci√≥n es 20% sintaxis y 80% l√≥gica!** üß†üí™

---
**Pr√≥ximo paso:** Seguir practicando con loops y condiciones para interiorizar estos conceptos.

---

**Happy Coding! üöÄ**
